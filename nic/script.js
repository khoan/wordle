const words = ["aback","abase","abate","abbey","abbot","abhor","abide","abled","abode","abort","about","above","abuse","abyss","acorn","acrid","actor","acute","adage","adapt","adept","admin","admit","adobe","adopt","adore","adorn","adult","affix","afire","afoot","afoul","after","again","agape","agate","agent","agile","aging","aglow","agony","agora","agree","ahead","aider","aisle","alarm","album","alert","algae","alibi","alien","align","alike","alive","allay","alley","allot","allow","alloy","aloft","alone","along","aloof","aloud","alpha","altar","alter","amass","amaze","amber","amble","amend","amiss","amity","among","ample","amply","amuse","angel","anger","angle","angry","angst","anime","ankle","annex","annoy","annul","anode","antic","anvil","aorta","apart","aphid","aping","apnea","apple","apply","apron","aptly","arbor","ardor","arena","argue","arise","armor","aroma","arose","array","arrow","arson","artsy","ascot","ashen","aside","askew","assay","asset","atoll","atone","attic","audio","audit","augur","aunty","avail","avert","avian","avoid","await","awake","award","aware","awash","awful","awoke","axial","axiom","axion","azure","bacon","badge","badly","bagel","baggy","baker","baler","balmy","banal","banjo","barge","baron","basal","basic","basil","basin","basis","baste","batch","bathe","baton","batty","bawdy","bayou","beach","beady","beard","beast","beech","beefy","befit","began","begat","beget","begin","begun","being","belch","belie","belle","belly","below","bench","beret","berry","berth","beset","betel","bevel","bezel","bible","bicep","biddy","bigot","bilge","billy","binge","bingo","biome","birch","birth","bison","bitty","black","blade","blame","bland","blank","blare","blast","blaze","bleak","bleat","bleed","bleep","blend","bless","blimp","blind","blink","bliss","blitz","bloat","block","bloke","blond","blood","bloom","blown","bluer","bluff","blunt","blurb","blurt","blush","board","boast","bobby","boney","bongo","bonus","booby","boost","booth","booty","booze","boozy","borax","borne","bosom","bossy","botch","bough","boule","bound","bowel","boxer","brace","braid","brain","brake","brand","brash","brass","brave","bravo","brawl","brawn","bread","break","breed","briar","bribe","brick","bride","brief","brine","bring","brink","briny","brisk","broad","broil","broke","brood","brook","broom","broth","brown","brunt","brush","brute","buddy","budge","buggy","bugle","build","built","bulge","bulky","bully","bunch","bunny","burly","burnt","burst","bused","bushy","butch","butte","buxom","buyer","bylaw","cabal","cabby","cabin","cable","cacao","cache","cacti","caddy","cadet","cagey","cairn","camel","cameo","canal","candy","canny","canoe","canon","caper","caput","carat","cargo","carol","carry","carve","caste","catch","cater","catty","caulk","cause","cavil","cease","cedar","cello","chafe","chaff","chain","chair","chalk","champ","chant","chaos","chard","charm","chart","chase","chasm","cheap","cheat","check","cheek","cheer","chess","chest","chick","chide","chief","child","chili","chill","chime","china","chirp","chock","choir","choke","chord","chore","chose","chuck","chump","chunk","churn","chute","cider","cigar","cinch","circa","civic","civil","clack","claim","clamp","clang","clank","clash","clasp","class","clean","clear","cleat","cleft","clerk","click","cliff","climb","cling","clink","cloak","clock","clone","close","cloth","cloud","clout","clove","clown","cluck","clued","clump","clung","coach","coast","cobra","cocoa","colon","color","comet","comfy","comic","comma","conch","condo","conic","copse","coral","corer","corny","couch","cough","could","count","coupe","court","coven","cover","covet","covey","cower","coyly","crack","craft","cramp","crane","crank","crash","crass","crate","crave","crawl","craze","crazy","creak","cream","credo","creed","creek","creep","creme","crepe","crept","cress","crest","crick","cried","crier","crime","crimp","crisp","croak","crock","crone","crony","crook","cross","croup","crowd","crown","crude","cruel","crumb","crump","crush","crust","crypt","cubic","cumin","curio","curly","curry","curse","curve","curvy","cutie","cyber","cycle","cynic","daddy","daily","dairy","daisy","dally","dance","dandy","datum","daunt","dealt","death","debar","debit","debug","debut","decal","decay","decor","decoy","decry","defer","deign","deity","delay","delta","delve","demon","demur","denim","dense","depot","depth","derby","deter","detox","deuce","devil","diary","dicey","digit","dilly","dimly","diner","dingo","dingy","diode","dirge","dirty","disco","ditch","ditto","ditty","diver","dizzy","dodge","dodgy","dogma","doing","dolly","donor","donut","dopey","doubt","dough","dowdy","dowel","downy","dowry","dozen","draft","drain","drake","drama","drank","drape","drawl","drawn","dread","dream","dress","dried","drier","drift","drill","drink","drive","droit","droll","drone","drool","droop","dross","drove","drown","druid","drunk","dryer","dryly","duchy","dully","dummy","dumpy","dunce","dusky","dusty","dutch","duvet","dwarf","dwell","dwelt","dying","eager","eagle","early","earth","easel","eaten","eater","ebony","eclat","edict","edify","eerie","egret","eight","eject","eking","elate","elbow","elder","elect","elegy","elfin","elide","elite","elope","elude","email","embed","ember","emcee","empty","enact","endow","enema","enemy","enjoy","ennui","ensue","enter","entry","envoy","epoch","epoxy","equal","equip","erase","erect","erode","error","erupt","essay","ester","ether","ethic","ethos","etude","evade","event","every","evict","evoke","exact","exalt","excel","exert","exile","exist","expel","extol","extra","exult","eying","fable","facet","faint","fairy","faith","false","fancy","fanny","farce","fatal","fatty","fault","fauna","favor","feast","fecal","feign","fella","felon","femme","femur","fence","feral","ferry","fetal","fetch","fetid","fetus","fever","fewer","fiber","fibre","ficus","field","fiend","fiery","fifth","fifty","fight","filer","filet","filly","filmy","filth","final","finch","finer","first","fishy","fixer","fizzy","fjord","flack","flail","flair","flake","flaky","flame","flank","flare","flash","flask","fleck","fleet","flesh","flick","flier","fling","flint","flirt","float","flock","flood","floor","flora","floss","flour","flout","flown","fluff","fluid","fluke","flume","flung","flunk","flush","flute","flyer","foamy","focal","focus","foggy","foist","folio","folly","foray","force","forge","forgo","forte","forth","forty","forum","found","foyer","frail","frame","frank","fraud","freak","freed","freer","fresh","friar","fried","frill","frisk","fritz","frock","frond","front","frost","froth","frown","froze","fruit","fudge","fugue","fully","fungi","funky","funny","furor","furry","fussy","fuzzy","gaffe","gaily","gamer","gamma","gamut","gassy","gaudy","gauge","gaunt","gauze","gavel","gawky","gayer","gayly","gazer","gecko","geeky","geese","genie","genre","ghost","ghoul","giant","giddy","gipsy","girly","girth","given","giver","glade","gland","glare","glass","glaze","gleam","glean","glide","glint","gloat","globe","gloom","glory","gloss","glove","glyph","gnash","gnome","godly","going","golem","golly","gonad","goner","goody","gooey","goofy","goose","gorge","gouge","gourd","grace","grade","graft","grail","grain","grand","grant","grape","graph","grasp","grass","grate","grave","gravy","graze","great","greed","green","greet","grief","grill","grime","grimy","grind","gripe","groan","groin","groom","grope","gross","group","grout","grove","growl","grown","gruel","gruff","grunt","guard","guava","guess","guest","guide","guild","guile","guilt","guise","gulch","gully","gumbo","gummy","guppy","gusto","gusty","gypsy","habit","hairy","halve","handy","happy","hardy","harem","harpy","harry","harsh","haste","hasty","hatch","hater","haunt","haute","haven","havoc","hazel","heady","heard","heart","heath","heave","heavy","hedge","hefty","heist","helix","hello","hence","heron","hilly","hinge","hippo","hippy","hitch","hoard","hobby","hoist","holly","homer","honey","honor","horde","horny","horse","hotel","hotly","hound","house","hovel","hover","howdy","human","humid","humor","humph","humus","hunch","hunky","hurry","husky","hussy","hutch","hydro","hyena","hymen","hyper","icily","icing","ideal","idiom","idiot","idler","idyll","igloo","iliac","image","imbue","impel","imply","inane","inbox","incur","index","inept","inert","infer","ingot","inlay","inlet","inner","input","inter","intro","ionic","irate","irony","islet","issue","itchy","ivory","jaunt","jazzy","jelly","jerky","jetty","jewel","jiffy","joint","joist","joker","jolly","joust","judge","juice","juicy","jumbo","jumpy","junta","junto","juror","kappa","karma","kayak","kebab","khaki","kinky","kiosk","kitty","knack","knave","knead","kneed","kneel","knelt","knife","knock","knoll","known","koala","krill","label","labor","laden","ladle","lager","lance","lanky","lapel","lapse","large","larva","lasso","latch","later","lathe","latte","laugh","layer","leach","leafy","leaky","leant","leapt","learn","lease","leash","least","leave","ledge","leech","leery","lefty","legal","leggy","lemon","lemur","leper","level","lever","libel","liege","light","liken","lilac","limbo","limit","linen","liner","lingo","lipid","lithe","liver","livid","llama","loamy","loath","lobby","local","locus","lodge","lofty","logic","login","loopy","loose","lorry","loser","louse","lousy","lover","lower","lowly","loyal","lucid","lucky","lumen","lumpy","lunar","lunch","lunge","lupus","lurch","lurid","lusty","lying","lymph","lynch","lyric","macaw","macho","macro","madam","madly","mafia","magic","magma","maize","major","maker","mambo","mamma","mammy","manga","mange","mango","mangy","mania","manic","manly","manor","maple","march","marry","marsh","mason","masse","match","matey","mauve","maxim","maybe","mayor","mealy","meant","meaty","mecca","medal","media","medic","melee","melon","mercy","merge","merit","merry","metal","meter","metro","micro","midge","midst","might","milky","mimic","mince","miner","minim","minor","minty","minus","mirth","miser","missy","mocha","modal","model","modem","mogul","moist","molar","moldy","money","month","moody","moose","moral","moron","morph","mossy","motel","motif","motor","motto","moult","mound","mount","mourn","mouse","mouth","mover","movie","mower","mucky","mucus","muddy","mulch","mummy","munch","mural","murky","mushy","music","musky","musty","myrrh","nadir","naive","nanny","nasal","nasty","natal","naval","navel","needy","neigh","nerdy","nerve","never","newer","newly","nicer","niche","niece","night","ninja","ninny","ninth","noble","nobly","noise","noisy","nomad","noose","north","nosey","notch","novel","nudge","nurse","nutty","nylon","nymph","oaken","obese","occur","ocean","octal","octet","odder","oddly","offal","offer","often","olden","older","olive","ombre","omega","onion","onset","opera","opine","opium","optic","orbit","order","organ","other","otter","ought","ounce","outdo","outer","outgo","ovary","ovate","overt","ovine","ovoid","owing","owner","oxide","ozone","paddy","pagan","paint","paler","palsy","panel","panic","pansy","papal","paper","parer","parka","parry","parse","party","pasta","paste","pasty","patch","patio","patsy","patty","pause","payee","payer","peace","peach","pearl","pecan","pedal","penal","pence","penne","penny","perch","peril","perky","pesky","pesto","petal","petty","phase","phone","phony","photo","piano","picky","piece","piety","piggy","pilot","pinch","piney","pinky","pinto","piper","pique","pitch","pithy","pivot","pixel","pixie","pizza","place","plaid","plain","plait","plane","plank","plant","plate","plaza","plead","pleat","plied","plier","pluck","plumb","plume","plump","plunk","plush","poesy","point","poise","poker","polar","polka","polyp","pooch","poppy","porch","poser","posit","posse","pouch","pound","pouty","power","prank","prawn","preen","press","price","prick","pride","pried","prime","primo","print","prior","prism","privy","prize","probe","prone","prong","proof","prose","proud","prove","prowl","proxy","prude","prune","psalm","pubic","pudgy","puffy","pulpy","pulse","punch","pupal","pupil","puppy","puree","purer","purge","purse","pushy","putty","pygmy","quack","quail","quake","qualm","quark","quart","quash","quasi","queen","queer","quell","query","quest","queue","quick","quiet","quill","quilt","quirk","quite","quota","quote","quoth","rabbi","rabid","racer","radar","radii","radio","rainy","raise","rajah","rally","ralph","ramen","ranch","randy","range","rapid","rarer","raspy","ratio","ratty","raven","rayon","razor","reach","react","ready","realm","rearm","rebar","rebel","rebus","rebut","recap","recur","recut","reedy","refer","refit","regal","rehab","reign","relax","relay","relic","remit","renal","renew","repay","repel","reply","rerun","reset","resin","retch","retro","retry","reuse","revel","revue","rhino","rhyme","rider","ridge","rifle","right","rigid","rigor","rinse","ripen","riper","risen","riser","risky","rival","river","rivet","roach","roast","robin","robot","rocky","rodeo","roger","rogue","roomy","roost","rotor","rouge","rough","round","rouse","route","rover","rowdy","rower","royal","ruddy","ruder","rugby","ruler","rumba","rumor","rupee","rural","rusty","sadly","safer","saint","salad","sally","salon","salsa","salty","salve","salvo","sandy","saner","sappy","sassy","satin","satyr","sauce","saucy","sauna","saute","savor","savoy","savvy","scald","scale","scalp","scaly","scamp","scant","scare","scarf","scary","scene","scent","scion","scoff","scold","scone","scoop","scope","score","scorn","scour","scout","scowl","scram","scrap","scree","screw","scrub","scrum","scuba","sedan","seedy","segue","seize","semen","sense","sepia","serif","serum","serve","setup","seven","sever","sewer","shack","shade","shady","shaft","shake","shaky","shale","shall","shalt","shame","shank","shape","shard","share","shark","sharp","shave","shawl","shear","sheen","sheep","sheer","sheet","sheik","shelf","shell","shied","shift","shine","shiny","shire","shirk","shirt","shoal","shock","shone","shook","shoot","shore","shorn","short","shout","shove","shown","showy","shrew","shrub","shrug","shuck","shunt","shush","shyly","siege","sieve","sight","sigma","silky","silly","since","sinew","singe","siren","sissy","sixth","sixty","skate","skier","skiff","skill","skimp","skirt","skulk","skull","skunk","slack","slain","slang","slant","slash","slate","slave","sleek","sleep","sleet","slept","slice","slick","slide","slime","slimy","sling","slink","sloop","slope","slosh","sloth","slump","slung","slunk","slurp","slush","slyly","smack","small","smart","smash","smear","smell","smelt","smile","smirk","smite","smith","smock","smoke","smoky","smote","snack","snail","snake","snaky","snare","snarl","sneak","sneer","snide","sniff","snipe","snoop","snore","snort","snout","snowy","snuck","snuff","soapy","sober","soggy","solar","solid","solve","sonar","sonic","sooth","sooty","sorry","sound","south","sower","space","spade","spank","spare","spark","spasm","spawn","speak","spear","speck","speed","spell","spelt","spend","spent","sperm","spice","spicy","spied","spiel","spike","spiky","spill","spilt","spine","spiny","spire","spite","splat","split","spoil","spoke","spoof","spook","spool","spoon","spore","sport","spout","spray","spree","sprig","spunk","spurn","spurt","squad","squat","squib","stack","staff","stage","staid","stain","stair","stake","stale","stalk","stall","stamp","stand","stank","stare","stark","start","stash","state","stave","stead","steak","steal","steam","steed","steel","steep","steer","stein","stern","stick","stiff","still","stilt","sting","stink","stint","stock","stoic","stoke","stole","stomp","stone","stony","stood","stool","stoop","store","stork","storm","story","stout","stove","strap","straw","stray","strip","strut","stuck","study","stuff","stump","stung","stunk","stunt","style","suave","sugar","suing","suite","sulky","sully","sumac","sunny","super","surer","surge","surly","sushi","swami","swamp","swarm","swash","swath","swear","sweat","sweep","sweet","swell","swept","swift","swill","swine","swing","swirl","swish","swoon","swoop","sword","swore","sworn","swung","synod","syrup","tabby","table","taboo","tacit","tacky","taffy","taint","taken","taker","tally","talon","tamer","tango","tangy","taper","tapir","tardy","tarot","taste","tasty","tatty","taunt","tawny","teach","teary","tease","teddy","teeth","tempo","tenet","tenor","tense","tenth","tepee","tepid","terra","terse","testy","thank","theft","their","theme","there","these","theta","thick","thief","thigh","thing","think","third","thong","thorn","those","three","threw","throb","throw","thrum","thumb","thump","thyme","tiara","tibia","tidal","tiger","tight","tilde","timer","timid","tipsy","titan","tithe","title","toast","today","toddy","token","tonal","tonga","tonic","tooth","topaz","topic","torch","torso","torus","total","totem","touch","tough","towel","tower","toxic","toxin","trace","track","tract","trade","trail","train","trait","tramp","trash","trawl","tread","treat","trend","triad","trial","tribe","trice","trick","tried","tripe","trite","troll","troop","trope","trout","trove","truce","truck","truer","truly","trump","trunk","truss","trust","truth","tryst","tubal","tuber","tulip","tulle","tumor","tunic","turbo","tutor","twang","tweak","tweed","tweet","twice","twine","twirl","twist","twixt","tying","udder","ulcer","ultra","umbra","uncle","uncut","under","undid","undue","unfed","unfit","unify","union","unite","unity","unlit","unmet","unset","untie","until","unwed","unzip","upper","upset","urban","urine","usage","usher","using","usual","usurp","utile","utter","vague","valet","valid","valor","value","valve","vapid","vapor","vault","vaunt","vegan","venom","venue","verge","verse","verso","verve","vicar","video","vigil","vigor","villa","vinyl","viola","viper","viral","virus","visit","visor","vista","vital","vivid","vixen","vocal","vodka","vogue","voice","voila","vomit","voter","vouch","vowel","vying","wacky","wafer","wager","wagon","waist","waive","waltz","warty","waste","watch","water","waver","waxen","weary","weave","wedge","weedy","weigh","weird","welch","welsh","wench","whack","whale","wharf","wheat","wheel","whelp","where","which","whiff","while","whine","whiny","whirl","whisk","white","whole","whoop","whose","widen","wider","widow","width","wield","wight","willy","wimpy","wince","winch","windy","wiser","wispy","witch","witty","woken","woman","women","woody","wooer","wooly","woozy","wordy","world","worry","worse","worst","worth","would","wound","woven","wrack","wrath","wreak","wreck","wrest","wring","wrist","write","wrong","wrote","wrung","wryly","yacht","yearn","yeast","yield","young","youth","zebra","zesty","zonal"]; // prettier-ignore

// Global Variables
let keys = document.getElementsByClassName("key");
const containerArr = document.getElementsByClassName("inputs");
const keyboard = document.getElementsByClassName("keyboard");
const chosenWord = []; //gets filled by startWordle funct
const wordArr = []; // user's word
let inputRow = 0; // y value
let letterColumn = 0; // x value
let remainingGuesses = 5; // guesses result count
let overallStreak = 0; // total words guessed
let currentStreak = 0; // current streak of correctly guessed words

let greenCount = 0;
const greenLetters = [];
const yellowLetters = [];
const redLetters = [];
let boardState = {
  wordsUsed: [],
  currentWord: [],
  gameState: "ACTIVE",
};
let previousHint = "";

// Function to choose a random word from the words array
const startWordle = () => {
  // check if there's a word currently stored in the boardState
  if (boardState.currentWord.length > 0) {
    // Gets a random word from the array
    //word = boardState.currentWord;
    //chosenWord.push(boardState.currentWord);
    boardState.currentWord.forEach((element) => {
      chosenWord.push(element.toUpperCase());
    });
  } else {
    let word;

    // Gets a random word from the array
    word = words[Math.floor(Math.random() * words.length)]
      .toUpperCase()
      .split("");

    // loop through and put each element of the split word array into a global const chosenWord array
    word.forEach((element) => {
      chosenWord.push(element.toUpperCase());
    });
    boardState.currentWord = chosenWord;
  }
  console.log(boardState);
  //console.log(chosenWord);
};

// Resets all the global variables for a new game to be played
const resetWordle = () => {
  //console.log(containerArr.length);
  // loop through each row of the inputs
  for (let i = 0; i < containerArr.length; i++) {
    // loop through each input column in the i'th row
    for (let j = 0; j < containerArr[i].children.length; j++) {
      //console.log(containerArr[i].children[j]);
      containerArr[i].children[j].innerText = "";
      containerArr[i].children[j].style.backgroundColor = "#333";
    }
  }

  keyboard[0].removeChild(keyboard[0].firstElementChild); // removes the newGameBtn
  chosenWord.length = 0;
  boardState.currentWord.length = 0;
  boardState.wordsUsed.length = 0;
  boardState.gameState = "ACTIVE";
  inputRow = 0;
  letterColumn = 0;
  remainingGuesses = 5;
  wordArr.length = 0;
  greenCount = 0;
  greenLetters.length = 0;
  yellowLetters.length = 0;
  redLetters.length = 0;
};

// Create Word Helper Button
const createWHBtn = () => {
  const btn = document.getElementById("wordHelperBtn");
  btn.addEventListener("click", function () {
    if (boardState.gameState === "ACTIVE") {
      //console.log("works 1");
      //console.log("helper btn works");
      let wordArr = [];
      let wordStr = "";
      //console.log(greenLetters);

      if (boardState.wordsUsed.length <= 0) {
        // currently works
        wordArr = ["A", "U", "D", "I", "O"];
        //console.log("works 2");
        wordStr = wordArr.join("");
      } else {
        wordArr = greenLetters[greenLetters.length - 1]; // gets the latest entry in the arr eg... [[....S], [.E..S], etc]
        //console.log("works 3");
        // green filter
        const result = words.filter((word) =>
          word.match(wordArr.join("").toLowerCase())
        );

        // yellow filter
        const yellowFilterWord = () => {
          const matchedWords = [];
          if (yellowLetters.length > 0) {
            for (let i = 0; i < result.length; i++) {
              //console.log(result[i], i);
              // result[i] is each individual word
              let testWord = "";
              // loop through the yellowLetters array and repeatetdly test to see if every yellow letter is present
              for (
                let j = 0;
                j < yellowLetters[yellowLetters.length - 1].length;
                j++
              ) {
                // yellowLetters[j] is each individual yellow letter
                if (
                  result[i].includes(
                    yellowLetters[yellowLetters.length - 1][j].toLowerCase()
                  )
                ) {
                  testWord = result[i];
                } else {
                  testWord = "";
                  break;
                }
              }
              //console.log(testWord);
              if (testWord) {
                matchedWords.push(testWord);
              }
            }
            //console.log(matchedWords, "yellow matched");
            return matchedWords;
          } else {
            return result;
          }
        };
        //console.log(redLetters, "red letters");
        // red filter
        const redFilterWord = () => {
          const yellowResult = yellowFilterWord();
          //console.log(yellowResult, "yellow result");
          const matchedWords = [];
          if (redLetters.length > 0) {
            for (let i = 0; i < yellowResult.length; i++) {
              // result[i] is each individual word
              let testWord = "";
              // loop through the yellowLetters array and repeatetdly test to see if every yellow letter is present
              for (let j = 0; j < redLetters.length; j++) {
                //console.log(yellowLetters[yellowLetters.length - 1][j]);
                // yellowLetters[j] is each individual yellow letter
                if (yellowResult[i].includes(redLetters[j].toLowerCase())) {
                  testWord = "";
                  break;
                } else {
                  testWord = yellowResult[i];
                }
              }
              //console.log(testWord);
              if (testWord) {
                matchedWords.push(testWord);
              }
            }
            return matchedWords;
          } else {
            return yellowResult;
          }
          //console.log(matchedWords);
        };
        const redResult = redFilterWord();

        //console.log(result);
        //console.log(yellowResult);
        //console.log(redResult, "red result");
        if (redResult.length <= 1) {
          wordStr = "NO WORD";
        } else {
          let randomResult =
            redResult[Math.floor(Math.random() * redResult.length)];
          if (
            randomResult ===
            boardState.wordsUsed[boardState.wordsUsed.length - 1]
              .join()
              .toLowerCase()
          ) {
            redResult.splice(redResult.indexOf(previousHint), 1);
            wordStr = redResult[Math.floor(Math.random() * redResult.length)];
          } else {
            wordStr = randomResult;
          }
        }
      }

      if (wordStr === "NO WORD") {
        window.alert("No more hints to give :) Good Luck");
      } else {
        window.alert(`Recommended word to use is ${wordStr}`);
        previousHint = wordStr;
      }
    } else {
      console.log("helper gameState not working");
    }
  });
};

// Create New Game Btn function
const createNGBtn = () => {
  const btn = document.createElement("button");
  btn.id = "nGameBtn";
  btn.addEventListener("click", function () {
    resetWordle();
    startWordle();
    focusInputRow();
    localStorage.clear("boardState");
  });
  btn.textContent = "New Game?";
  // puts the btn elemtent in the first position
  keyboard[0].insertAdjacentElement("afterbegin", btn);
};

// Updates the onscreen overall and current word streak text content
const updateStreak = () => {
  const streakText = document.getElementById("wStreak");
  streakText.textContent = `${currentStreak} / ${overallStreak} word streak`;
};

// Gives the ability to open and close the help screen modal
const initHelpModal = () => {
  const helpModal = document.getElementById("helpModal"); // get the help modal
  const helpBtn = document.getElementById("helpBtn");
  const closeModal = document.getElementsByClassName("close")[0];

  helpBtn.addEventListener("click", function () {
    //helpModal.style.display = "block";
    helpModal.classList.add("open");
  });

  closeModal.addEventListener("click", function () {
    //helpModal.style.display = "none";
    helpModal.classList.remove("open");
  });
};

// Handles everything to do with letters being clicked/types + most of the game logic
const logKey = (e) => {
  if (boardState.gameState === "ACTIVE") {
    let letter;
    // checks if the passed value is from a keyboard event or from the onscreen keyboard
    if (e.constructor.name === "KeyboardEvent") {
      letter = e.key.toUpperCase();
    } else {
      letter = e.toUpperCase();
    }
    //console.log(letter);

    // checks if letter is number vs capital letter
    const letterMatch = letter.match(/[A-Z]/g);
    if (e.keyCode === 13 || e === "↵") {
      // Do this if Enter is pressed
      // when enter is pressed plus the x value and run a function to check result

      // only run function if the letterColumn is >= 5
      if (letterColumn >= 5) {
        //console.log("Enter was pressed");

        const rowArr = containerArr[inputRow].children;
        // loop through y row and get all x values and push into an array

        // check if the word actually exists
        if (words.includes(wordArr.join("").toLowerCase())) {
          // compare the wordArr result to the chosenWord array
          //console.log(wordArr, "wordArr");
          const currentRowGreen = [];
          const currentRowYellow = [];
          let remainingLetters = chosenWord.join("");
          const time = 300;
          const delay = 2000;

          // check green
          for (let i = 0; i < 5; i++) {
            if (chosenWord[i] === wordArr[i]) {
              remainingLetters = remainingLetters.replace(wordArr[i], "");
              //console.log(rowArr[j]);
              greenCount++;
              currentRowGreen.push(wordArr[i]);

              setTimeout(function () {
                rowArr[i].animate(
                  [
                    { transform: "rotateY(0deg)" },
                    { transform: "rotateY(180deg)" },
                    {
                      transform: "rotateY(360deg)",
                      backgroundColor: "#78ca00",
                    },
                  ],
                  delay
                );

                setTimeout(function () {
                  rowArr[i].style.backgroundColor = "#78ca00";
                }, delay);
              }, i * time);
            } else {
              // add red background
              rowArr[i].style.backgroundColor = "#aa0000";
              if (!redLetters.includes(wordArr[i])) {
                redLetters.push(wordArr[i]);
              }
              currentRowGreen.push(".");

              setTimeout(function () {
                rowArr[i].animate(
                  [
                    { transform: "rotateY(0deg)" },
                    { transform: "rotateY(180deg)" },
                    {
                      transform: "rotateY(360deg)",
                      backgroundColor: "#aa0000",
                    },
                  ],
                  delay
                );

                setTimeout(function () {
                  rowArr[i].style.backgroundColor = "#aa0000";
                }, delay);
              }, i * time);
            }
          }
          // check yellow
          for (let i = 0; i < 5; i++) {
            if (
              remainingLetters.includes(wordArr[i]) &&
              wordArr[i] !== chosenWord[i]
            ) {
              remainingLetters = remainingLetters.replace(wordArr[i], "");
              // add yellow background
              rowArr[i].style.backgroundColor = "#ffef0d";
              if (!currentRowYellow.includes(wordArr[i])) {
                currentRowYellow.push(wordArr[i]);
              }

              setTimeout(function () {
                rowArr[i].animate(
                  [
                    { transform: "rotateY(0deg)" },
                    { transform: "rotateY(180deg)" },
                    {
                      transform: "rotateY(360deg)",
                      backgroundColor: "#ffef0d",
                    },
                  ],
                  delay
                );

                setTimeout(function () {
                  rowArr[i].style.backgroundColor = "#ffef0d";
                }, delay);
              }, i * time);
            }
          }

          // check if redLetters contains anything from greenLetters or yellowLetters
          // if redLetters contains any of them then splice them out

          for (let j = 0; j < redLetters.length; j++) {
            if (
              currentRowGreen.includes(redLetters[j]) ||
              currentRowYellow.includes(redLetters[j])
            ) {
              // get position of specific redLetter
              // splice it out of redLetter arr
              redLetters.splice(j, 1);
              //console.log(redLetters, "post splice");
            }
          }

          // check if all are correct, if not move to next row etc
          if (greenCount >= 5) {
            alert(
              `You got the word ${chosenWord.join("")} in ${
                6 - remainingGuesses
              } guesses`
            );
            //inputRow++; // adds to row count to make the unfocus function work
            overallStreak++;
            currentStreak++;
            //unfocusPreviousRow();
            updateStreak();
            createNGBtn();
            boardState.wordsUsed.push([...wordArr]);
            boardState.gameState = "WON";
          } else {
            // Check if final row. If so end game, if not move to next row
            if (remainingGuesses <= 0) {
              alert(`You lost! The secret word is ${chosenWord.join("")}`);
              //inputRow++; // adds to row count to make the unfocus function work
              createNGBtn(); // creates New Game Button
              //unfocusPreviousRow();
              //inputRow--; // moves the cursor back so the body "click" handler works
              overallStreak++;
              currentStreak = 0;
              updateStreak();
              boardState.wordsUsed.push([...wordArr]);
              boardState.gameState = "LOST";
            } else {
              // everything else
              boardState.wordsUsed.push([...wordArr]);
              inputRow++; // moves cursor to next row
              letterColumn = 0; // moves cursor to first column
              //console.log(storeBoardState);
              remainingGuesses--; // deducts guess count by 1
              unfocusPreviousRow(); // removes event listeners and blurs previous row
              focusInputRow(); // adds event listeners and focuses new row
              wordArr.length = 0; // empties user word guess
              greenCount = 0;
              greenLetters.push(currentRowGreen);
              yellowLetters.push(currentRowYellow);
              //greenLetters.length = 0;
            }
          }
        } else {
          // do this if the word doesn't exist
          for (let i = 0; i < rowArr.length; i++) {
            rowArr[i].style.animation = "shake 1s ease-in";
            setTimeout(function () {
              rowArr[i].style.animation = "";
            }, 1000);
          }
        }
      }
    } else if (e.keyCode === 8 || e === "←") {
      // Do this is if backspace has been pressed
      //console.log("backspace was pressed");

      // stops backspace being pressed if there's no letters
      if (letterColumn >= 1) {
        // move the position of the "cursor" back one
        letterColumn--;
        // clear the x value
        containerArr[inputRow].children[letterColumn].textContent = "";

        wordArr.pop();
      }
      //console.log(containerArr[inputRow].children[letterColumn].textContent);
    } else if (
      !letterMatch ||
      (letterMatch.length > 1 && !(e.keyCode === 8)) ||
      (e.keyCode >= 112 && e.keyCode <= 123)
    ) {
      // Do nothing if a number or anything not a letter is pressed

      //console.log("number or something was pressed");
      return;
    } else {
      // Do this if a letter is pressed

      // stop the auto-move etc when the x value >= 5
      if (letterColumn < 5) {
        // when typed put letter in y row in x column and + 1 the x value
        containerArr[inputRow].children[letterColumn].textContent = letter;
        //console.log(containerArr[inputRow].children[letterColumn]);
        letterColumn++;
        wordArr.push(letter);
      }
    }
  } else {
    console.log(`Game ${boardState.gameState} so you can't keep playing`);
  }
};

// Adds event listeners and focuses row
const focusInputRow = () => {
  for (let i = 0; i < containerArr[inputRow].children.length; i++) {
    //console.log(containerArr[inputRow].children[i]);

    // applies tab index to each div just to check if they can be typed in etc
    containerArr[inputRow].children[i].tabIndex = i;

    // apply focus function to the first element in the row
    containerArr[inputRow].firstElementChild.focus();

    // adds event lisenter to each individual letter div in the respective row
    containerArr[inputRow].children[i].addEventListener("keydown", logKey);
  }
};

// Removes event listeners and blurs previous row
const unfocusPreviousRow = () => {
  const previousRow = containerArr[inputRow - 1];
  for (let i = 0; i < previousRow.children.length; i++) {
    // applies tab index to each div just to check if they can be typed in etc
    previousRow.children[i].removeAttribute("tabindex");

    // apply focus function to the first element in the row
    previousRow.firstElementChild.blur();

    // adds event lisenter to each individual letter div in the respective row
    previousRow.children[i].removeEventListener("keydown", logKey, true);
  }
};

// Init game state
const initGameState = () => {
  const containerArr = document.getElementsByClassName("inputs");
  // pulls from localStorage etc
  if (localStorage.getItem("wordStreaks") !== null) {
    //console.log(localStorage.getItem("wordStreaks"));
    let streakObj = JSON.parse(localStorage.getItem("wordStreaks"));
    console.log(streakObj);
    currentStreak = streakObj.currentStreak;
    overallStreak = streakObj.overallStreak;
  }
  // gets the boardState from localStorage and puts in on the screen
  if (localStorage.getItem("boardState")) {
    let testGreen = 0;
    boardState = JSON.parse(localStorage.getItem("boardState"));
    //console.log(boardState.gameState);

    // loop through the boardState.wordsUsed to the y values sorted
    for (let i = 0; i < boardState.wordsUsed.length; i++) {
      const currentRowGreen = [];
      const currentRowYellow = [];
      const loopRedLetters = [];
      let remainingLetters = boardState.currentWord.join("");

      // check green
      for (let j = 0; j < 5; j++) {
        if (boardState.wordsUsed[i][j] === boardState.currentWord[j]) {
          remainingLetters = remainingLetters.replace(
            boardState.wordsUsed[i][j],
            ""
          );
          // add green background
          containerArr[i].children[j].style.backgroundColor = "#78ca00";
          containerArr[i].children[j].textContent = boardState.wordsUsed[i][j];
          currentRowGreen.push(boardState.wordsUsed[i][j]);
          testGreen++;
        } else {
          // add red background
          containerArr[i].children[j].style.backgroundColor = "#aa0000";
          containerArr[i].children[j].textContent = boardState.wordsUsed[i][j];
          loopRedLetters.push(boardState.wordsUsed[i][j]);
          currentRowGreen.push(".");
        }
      }
      // check yellow
      for (let j = 0; j < 5; j++) {
        if (
          remainingLetters.includes(boardState.wordsUsed[i][j]) &&
          boardState.wordsUsed[i][j] !== boardState.currentWord[j]
        ) {
          remainingLetters = remainingLetters.replace(
            boardState.wordsUsed[i][j],
            ""
          );
          // add yellow background
          containerArr[i].children[j].style.backgroundColor = "#ffef0d";
          containerArr[i].children[j].textContent = boardState.wordsUsed[i][j];
          currentRowYellow.push(boardState.wordsUsed[i][j]);
        }
      }

      // check if redLetters contains anything from greenLetters or yellowLetters
      // if redLetters contains any of them then splice them out
      const testRed = [...loopRedLetters];
      for (let j = 0; j < loopRedLetters.length; j++) {
        //console.log(currentRowYellow.includes(loopRedLetters[j]), j);
        if (
          currentRowYellow.includes(loopRedLetters[j]) ||
          currentRowGreen.includes(loopRedLetters[j])
        ) {
          // get position of specific redLetter
          // splice it out of redLetter arr
          testRed.splice(j, 1, ".");
          //console.log(testRed[j], " spliced");
        } else {
          //console.log(j, "not spliced");
        }
      }
      for (let j = 0; j < testRed.length; j++) {
        if (testRed[j] !== ".") {
          redLetters.push(testRed[j]);
        }
      }
      //console.log(redLetters, "red letters");
      // end colour/letter check

      //console.log(currentRowGreen);

      if (i < boardState.wordsUsed.length && testGreen < 5) {
        testGreen = 0;
        remainingGuesses--;
        inputRow++;
        //letterColumn = 0;
        greenLetters.push(currentRowGreen);
        if (currentRowYellow.length > 0) {
          yellowLetters.push(currentRowYellow);
        }

        //console.log(greenLetters);
        //console.log(yellowLetters, "yellow letters");
        //console.log(redLetters, "red letters");
      }
      if (testGreen >= 5) {
        boardState.gameState = "WIN";
      }
      if (remainingGuesses <= 0) {
        boardState.gameState = "LOST";
      }

      // end of main loop
    }

    console.log(greenLetters, "green letters");
    console.log(yellowLetters, "yellow letters");
    console.log(redLetters, "red letters");
    greenCount = testGreen;
    if (greenCount >= 5 || remainingGuesses <= 0) {
      createNGBtn();
    }
  }
  if (boardState.gameState === "ACTIVE") {
    focusInputRow();
    startWordle();
  }
  //console.log(greenCount);
  //console.log(remainingGuesses);

  // makes sure the input divs are always focused no matter where you click on the screen
  document.body.addEventListener("click", function () {
    containerArr[inputRow].firstElementChild.focus();
  });

  // inits the onscreen keyboard click funtionality
  for (let i = 0; i < keys.length; i++) {
    let key = keys[i].textContent;
    keys[i].addEventListener("click", function () {
      containerArr[inputRow].firstElementChild.focus();
      logKey(key);
    });
  }

  // starts help modal stuff
  initHelpModal();

  // starts helper button stuff
  createWHBtn();

  //console.log(localStorage.getItem("wordStreaks"));
  updateStreak();
  //console.log(currentStreak);
  //console.log(overallStreak);

  //console.log(greenCount);
  //console.log(inputRow);
};

// Save game state on window unload
window.onbeforeunload = () => {
  if (localStorage.getItem("boardState") === JSON.stringify(boardState)) {
    console.log("Same Board state");
  } else {
    streakObj = {
      currentStreak: currentStreak,
      overallStreak: overallStreak,
    };
    localStorage.setItem("wordStreaks", JSON.stringify(streakObj));

    localStorage.setItem("boardState", JSON.stringify(boardState));
  }
  //localStorage.removeItem("wordStreaks");
  // prevents any pop-ups from occurring
  return null;
};

initGameState();
